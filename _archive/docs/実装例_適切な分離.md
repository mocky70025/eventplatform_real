# 実装例：適切な分離

## 現在のコードから学ぶ良い例

### ✅ 良い例：WelcomeScreen.tsx のアイコン実装

```tsx
// 1. SVGアイコンをコンポーネントとして分離（静的な要素）
const GoogleIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
    <path d="..." fill="#4285F4"/>
    <path d="..." fill="#34A853"/>
    {/* 絵だけを定義 */}
  </svg>
)

const MailIcon = ({ color = '#FFFFFF' }: { color?: string }) => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
    <path d="..." fill={color}/>  {/* 色だけは動的に変更可能 */}
  </svg>
)

// 2. React + CSS でボタンを実装（動的な要素）
export default function WelcomeScreen() {
  const [loading, setLoading] = useState(false);
  
  return (
    <button
      onClick={handleGoogleLogin}  // React: クリック処理
      disabled={loading}  // React: 状態管理
      style={{  // CSS: 見た目
        width: '100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '16px 24px',
        background: '#ffffff',
        borderRadius: '12px',
        cursor: loading ? 'not-allowed' : 'pointer'
      }}
    >
      {/* SVG: アイコン（静的な絵） */}
      <div style={{ position: 'absolute', left: '24px' }}>
        <GoogleIcon />
      </div>
      
      {/* React: テキスト（動的な表示） */}
      <span>Google</span>
    </button>
  );
}
```

**なぜ良いか**：
- ✅ SVGアイコンはコンポーネントとして分離（再利用可能）
- ✅ ボタンはReactで実装（状態管理、イベント処理）
- ✅ CSSで見た目を指定（色、サイズ、レイアウト）
- ✅ 役割が明確に分離されている

---

## 適切に分離するために必要なこと

### 1. Figmaから正確な情報を取得する

**必要な情報**：
- 位置（x, y座標）
- サイズ（width, height）
- 色（HEX値）
- フォント（サイズ、ウェイト、行間）
- 余白（padding, margin, gap）
- どの部分が静的か動的か

**取得方法**：
```bash
# Figma MCPツールを使用
Figma URLを提供 → デザイン情報を取得
```

### 2. 役割を判断する

#### 判断フローチャート

```
Figmaの要素を見る
    ↓
「これって変化する？」と聞く
    ↓
    ├─ 変化しない（アイコン、ロゴ、装飾）
    │   └─ SVGで実装
    │
    └─ 変化する（入力、ボタン、データ表示）
        └─ React + CSSで実装
```

#### 具体例

| Figmaの要素 | 変化する？ | 実装方法 |
|---|---|---|
| 戻るボタンの矢印アイコン | ❌ 変化しない | SVG |
| 入力フィールド | ✅ 値が変わる | React + CSS |
| 送信ボタン | ✅ クリックで処理 | React + CSS |
| ロゴ | ❌ 変化しない | SVG |
| エラーメッセージ | ✅ 条件で表示 | React + CSS |
| 装飾的な背景パターン | ❌ 変化しない | SVG |

### 3. 実装の手順

#### ステップ1: 静的要素（SVG）を実装

```tsx
// アイコンコンポーネントを作成
const BackArrowIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
    <path d="M15 18l-6-6 6-6" stroke="#000" strokeWidth="2"/>
  </svg>
);

// または、Figmaから取得したSVGをそのまま使用
const DecorativePattern = () => (
  <svg width="200" height="200" viewBox="0 0 200 200">
    {/* FigmaからコピーしたSVGパス */}
    <circle cx="100" cy="100" r="80" fill="#FF8A5C" opacity="0.1"/>
  </svg>
);
```

#### ステップ2: 動的要素（React + CSS）を実装

```tsx
function EventForm() {
  // React: 状態管理
  const [eventName, setEventName] = useState('');
  const [error, setError] = useState('');
  
  return (
    <div>
      {/* React: 入力フィールド */}
      <input
        type="text"
        value={eventName}  // React: データ表示
        onChange={(e) => setEventName(e.target.value)}  // React: データ更新
        style={{  // CSS: 見た目（Figmaから取得した値を使用）
          padding: '12px 16px',
          border: '1px solid #E5E5E5',
          borderRadius: '8px',
          fontSize: '16px',
          color: '#2C3E50'
        }}
      />
      
      {/* React: エラー表示 */}
      {error && (
        <p style={{ color: 'red', fontSize: '14px' }}>
          {error}
        </p>
      )}
    </div>
  );
}
```

#### ステップ3: 組み合わせる

```tsx
function EventForm() {
  const [eventName, setEventName] = useState('');
  
  return (
    <div style={{ background: '#E8F5F5', minHeight: '100vh' }}>
      {/* SVG: 静的な装飾（背景パターン） */}
      <div style={{ 
        position: 'absolute', 
        top: 0, 
        right: 0,
        opacity: 0.1,
        pointerEvents: 'none'  // クリックイベントを無効化
      }}>
        <DecorativePattern />
      </div>
      
      {/* React + CSS: 動的なフォーム */}
      <div style={{ padding: '24px', position: 'relative', zIndex: 1 }}>
        {/* 戻るボタン */}
        <button
          onClick={handleBack}
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: '8px',
            background: 'transparent',
            border: 'none',
            cursor: 'pointer'
          }}
        >
          {/* SVG: アイコン（静的な絵） */}
          <BackArrowIcon />
          {/* React: テキスト */}
          <span>戻る</span>
        </button>
        
        {/* React: 入力フィールド */}
        <input
          type="text"
          value={eventName}
          onChange={(e) => setEventName(e.target.value)}
          style={{
            width: '100%',
            padding: '12px 16px',
            border: '1px solid #E5E5E5',
            borderRadius: '8px'
          }}
        />
      </div>
    </div>
  );
}
```

---

## 実装チェックリスト

実装時に以下を確認：

### SVGを使うべきか？
- [ ] この要素は変化しないか？（アイコン、ロゴ、装飾）
- [ ] ユーザーの操作で値が変わることはないか？
- [ ] 状態に応じて表示が変わることはないか？

→ **全て「はい」ならSVG**

### React + CSSを使うべきか？
- [ ] この要素はデータを表示するか？（入力値、計算結果など）
- [ ] ユーザーの操作に反応するか？（クリック、入力など）
- [ ] 状態に応じて見た目が変わるか？（無効化、エラーなど）
- [ ] 条件によって表示/非表示が変わるか？

→ **1つでも「はい」ならReact + CSS**

---

## よくある間違いと正しい実装

### ❌ 間違い1: 全てSVGで実装しようとする

```tsx
// ❌ 悪い例
<svg>
  <foreignObject>
    <input value={data} onChange={...} />  // 複雑で扱いにくい
  </foreignObject>
</svg>
```

```tsx
// ✅ 正しい例
<div>
  <input value={data} onChange={...} />  // React + CSSで実装
</div>
```

### ❌ 間違い2: SVG内で状態管理しようとする

```tsx
// ❌ 悪い例
<svg>
  <rect 
    fill={isLoading ? "#D9D9D9" : "#FF8A5C"}  // SVG内で状態を扱う
    onClick={() => setIsLoading(true)}
  />
</svg>
```

```tsx
// ✅ 正しい例
<button
  onClick={() => setIsLoading(true)}
  style={{
    background: isLoading ? '#D9D9D9' : '#FF8A5C'  // React + CSSで状態を扱う
  }}
>
  送信
</button>
```

### ❌ 間違い3: 動的な要素をSVGで描こうとする

```tsx
// ❌ 悪い例
<svg>
  <text x="100" y="50">
    {error ? 'エラー' : '正常'}  // SVG内で条件分岐
  </text>
</svg>
```

```tsx
// ✅ 正しい例
{error && (
  <p style={{ color: 'red' }}>エラー</p>  // Reactで条件付き表示
)}
```

---

## まとめ

**適切に分離する = 静的な部分と動的な部分を明確に分ける**

### 必要なもの

1. **Figmaからの正確な情報**
   - 位置、サイズ、色、フォントなど

2. **判断基準**
   - 変化する？ → React + CSS
   - 変化しない？ → SVG

3. **実装の順序**
   - 静的要素（SVG）を先に実装
   - 動的要素（React + CSS）を実装
   - 組み合わせて統合

### 役割分担

- **SVG**: 絵を描く（静的な装飾）
- **React**: 動きやデータを扱う（機能）
- **CSS**: 見た目を決める（スタイル）

この3つを適切に組み合わせることで、**Figmaのデザインを正確に再現しつつ、動的な機能も実装できる**ようになります。


